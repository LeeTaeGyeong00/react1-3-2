# 이태석 202230229

# 6월 05일 강의

## STATE 끌어 올리기

### 12.1 shared state

- shared state는 state의 공유를 의미합니다
- 같은 부모 컴포넌트의 state를 자식 컴포넌트가 공유해서 사용하는 것 입니다.
- 다음 그림은 부모 컴포넌트가 섭씨 온도의 state를 갖고있고, 이것을 컴포넌트 C와 컴포넌트 F가 공유해서 사용하는 것을 보여줍니다.

## ch13 합성 VS 상속

### 13.1 합성에 대해 알아보기

- 합성(Composition)은 여러개의 컴포넌트를 합쳐서 새로운 컴포넌트를 만드는 것입니다

#### [1] containment(담다, 포함하다, 격리하다)

- 특정 컴포넌트가 하위 컴포넌트를 포함하는 형태의 합성 방법입니다.
- 컴포넌트에 따라서는 어떤 자식 엘리먼트가 들어올 지 미리 예상 할 수 없는 경우가 있습니다.
- 범용적인 '박스' 역할을 하는 sidevar혹은 Dialog와 같은 컴포넌트에서 특히 자주 볼 수 있스니다
- 이런 컴포넌트에서는 children prop을 사용하여 자식 엘리먼트를 출력하여 그대로 전달 하는 것이 좋습니다
- 이때 children prop은 컴포넌트의 prps에 기본적으로 들어있는 children 속성을 사용합니다.
- 다음과 같이 props.children을 사용하면 해당 컴포넌트의 하위 컴포넌트가 모두 children으로 들어오게 됩니다.

```jsx
function FancyBorder(props) {
	return (
		<div
			className={"FancyBoarder FancyBorder-" + props.color}
		>
			{props.children}
		</div>
	);
}
```

- children은 다음 구조에서 세번쨰 들어가는 파라미터입니다.
- 파라미터가 배열로 되어있는 이유는 여러개의 하위 컴포넌트를 가질수 있기 때문입니다.
- children이 배열로 되어있는 것은 여러개의 하위 컴포넌트를 위한 것입니다.

```jsx
React.createElement(type, [props], [...children]);
```

- 리액트에서는 props.children을 통해 하위 컴포넌트를 하나로 모아서 제공해 줍니다.
- 만일 여러개의 children집합이 필요할 경우는 별도로 props를 정의해서 각각 원하는 컴포넌트를 넣어줍니다.
- 예와 같이 SplitPane은 화면을 왼쪽과 오른쪽으로 분할 해 주고, App에서는 SplitPane을 사용해서 left, right 두개의 props를 정의 하고 있습니다
- 즉 app에서 left, right를 props를 받아서 화면을 분할 하게 됩니다. 이처럼 여러개의 children집합이 필요한 경우 별도의 props를 정의 해서 사용합니다.

```jsx
function SplitPane(props) {
	return (
		<div className="SplitPane">
			<div className="SplitPane-left">{props.left}</div>
			<div className="SplitPane-right">{props.right}</div>
		</div>
	);
}
```

```jsx
function App(props) {
	return <SplitPane left={<Contacts />} right={<Chat />} />;
}
```

#### [2] Specialization(특수화, 전문화)

- 웰컴 다이얼로그는 다이얼로그의 특별한 케이스입니다.
- 범용적인 개념을 구별이 되게 구체화하는 것을 특수화라고 합니다.
- 리액트에서는 합성을 사용하여 특수화를 구현합니다.
- 다음 예와 같이 특수화하는 범용적으로 쓸수 있는 컴포넌트를 만들어 놓고 이를 특수한 목적으로 사용하는 합성 방식입니다.

```jsx
function Dialog(props) {
	return (
		<FancyBorder color="blue">
			<h1 className="Dialog-title">{props.title}</h1>
			<p className="Dialog-message">{props.message}</p>
		</FancyBorder>
	);
}

function WelcomeDialog(props) {
	return (
		<Dialog
			title="어서오세요"
			message="사이트에 방문하신 것을 환영합니다."
		/>
	);
}
```

# 5월 29일 강의

### file input 태그

- 태그는 그 값이 읽기 전용이기 떄문에 리엑트에서는 비제어 컴포넌트가 됩니다

### Input Null Value

- 제어 컴포넌트에 value prop을 정해진 값으로 넣으면 코드를 수정하지 않는 한 입력 값을 바꿀 수 없습니다
- 만약 value prop은 넣되 자유롭게 입력 할 수 있게 만들고 싶다면 값이 undefined또는 null을 넣어주면 됩니다.

```jsx
ReactDOM.render(<input value="hi" />, rootNode);
setTimeout(function () {
	ReactDOM.render(<input value={null} />, rootNode);
}, 1000);
```

# 5월 22일 강의

## ch10 리스트와 키

#### 10.4 리스트의 키에 대해 알아보기

- 리스트에서의 키는 "리스트에서 아이템으로 구별하기 위한 고유한 문자열"입니다
- 이키는 리스트에서 어떤 아이템이 변경, 추가 또는 제거되었는지 구분하기 위해 사용
- 키는 같은 리스트에 있는 엘리언트 사이엥서만 고유한 값이면 됩니다

## ch11 폼

### 폼이란 무엇인가?

- 폼은 일반적으로 사용자부터 입력을 받기 위한 양식에서 많이 사용됩니다.

## 5월 8일 강의

#### 8.2 Arguments 전달하기

- 함수를 정의 할 때는 파라미터 혹은 매개변수
- 함수를 사용할 때는 아규먼트 혹은 인수라고 부릅니다
- 이벤트 핸들러에 매개변수를 전달해야하는 경우도 많습니다.

```jsx
<button onClick={(event) => this.deleteItem(id,event)}>삭제하기</button>
<button onClick={this.deleteItem.bind(this.id)}>삭제하기</button>
```

- event라는 매개변수는 리액트의 이벤트 객체를 의미합니다.
- 두방법 모두 첫번째 매개변수는 id이고 두번째 매개변수로 event가 전달됩니다.
- 첫번째 코드는 명시적으로 event를 매개변수로 넣어주었고, 두 번째 코드는 id 이후 두번째 매개변수로 event가 자동 전달됨

### ch09 조건부 렌더링

#### 9.3 인라인 조건

- 필요한 곳에 조건문을 직접 넣어 사용하는 방법

1. 인라인 if

- if 문을 직접 사용하지 않고 동일한 효과를 내기 위해 && 논리 연산자를 사용
- && 는 and 연자로 모든조건이 참일때만 참이 됩니다.
- 첫번째 조건이 거짓이면 두번째 조건을 판단할 필요 X 단축 평가

2. 인라인 if-else

- 삼항 연산자 사용
- 문자열이나 엘리먼트를 넣어서 사용가능

## 5월 1일 강의

### 7.7 훅의 규칙 (훅의 두가지 규칙)

1. 첫번째 규칙은 무조건 최상위 레벨에서만 호출 해야 한다는 것입니다.
2. 따라서 반복문이나 조건문 또는 중첩된 함수 들 안에서 흑을 호출 하면 안됩니다.
3. 이 규칙에 따라서 훅은 컴포넌트가 렌더링 될때마다 같은 순서로 호출 되어야합니다.
4. 두번째 규칙은 함수형 컴포넌트에서만 훅을 호출 해야한다는 것입니다.
5. 따라서 일반 JS 함수에서 훅을 호출하면 안됩니다.
6. 훅은 함수형 컴포넌트 혹은 직접 만든 커스텀 훅에서만 호출할 수 있습니다.

### 8장 이벤트 핸들링

#### 8.1 이벤트 처리하기 (DOM, React의 차이점)

1. 이벤트가 발생했을때 해당 이벤트를 처리하는 함수 = 이벤트 핸들러
2. 이벤트가 발생하는 것을 계속 듣고 있다는 의미 = 이벤트 리스너

## 4월 17일 강의

### 7훅

1. 훅이란 무엇인가

- 클래스형 컴포넌트에서는 생성자에서 state를 정의하고, setState()함수를 통해 state를 업데이트합니다
- 예전에 사용하던 함수형 컴포넌트는 별도롤 state를 정의하거나 컴포넌트의 생명주기에 맞춰서 어떤코드가 실행되도록 할 수 없었습니다.
- 함수형 컴포넌트에서도 state나 생명주기 함수의 기능을 사용하게 해주기 위해 추가된 기능이 바로 훅입니다.
- 함수형 컴포넌트에서도 훅을 사용하여 클래스형 컴포넌트의 기능을 모두 옹일하기 구현 할 수 있게 되었습니다.
- hook이란 state와 생명주기 기능에 갈고리를 걸어 원하는 시점에 정해진 함수를 실행되도록 만든 함수를 의미합니다.
- 훅의 이름은 모두 use로 시작합니다
- 사용자 정의 훅을 만들 수 있으며, 이경우에 이름은 자유롭게 할 수 있으나 'use' 로 시작할 것을 권장합니다.

2. useState

```jsx
import { useState } from "react";

export default function Counter(props) {
	//let count = 0;
	const [count, setCount] = useState(0);

	return (
		<>
			<p>총{count}</p>
			<button>
				onClick={() => setCount(count + 1)}
				클릭
			</button>
		</>
	);
}
```

3. **useEffect**

- usetate와 함께 가장 많이 사용하는 HOOK입니다
- 이 함수는 사이드 이펙트를 수행하기 위한 것
- 영어로 side effect는 부작용을 의미합니다.
- 리액트에서는 효과 또는 영향을 뜻하는 effect의 의미에 가깝습니다
- 이 작업은 다른 컴포넌트에 영향을 미칠 수 있으며, **렌더링중에는 작업이 완료될 수 없기 때문**입니다. 렌더링이 끝난 이후에 실행되어야하는 작업들
- 첫번쨰 파라미터는 이펙트 함수가 들어가고 두번쨰 파라미터로는 의존성 배열이 들어갑니다

```jsx
useEffect(이펙트 함수, 의존성 배열)
```

- 의존성 배열은 의존하고 있는 배열로, 배열 안에 있는 변수중에 하나라도 값이 변경되었을 때 이펙트 함수 실행
- 이펙트 함수는 처음 컴포넌트가 렌더링된 이후, 그리고 재 렌더링 이후에 실행됩니다.

4. useMemo

- useMemo() 훅은 Memoized value를 리턴하는 훅입니다.
- 이전 계산값을 갖고 있기 때문에 연상량이 많은 작업의 반복을 피할 수 있습니다.
- 이훅은 렌더링이 일어나는동안 실행 됩니다.
- 따라서 렌더링이 일어나는동한 실행돼서는 안될 작업을 넣으면 안됩니다.
  useEffect에서 실행 되어야 할 사이드 이펙트 같은 것

```jsx
const memoizedValue = useMemo(() => {
  //연상량이 높은 작업을 수행하여 결과를 반환
  return computeExpensiveValue(의존성 변수1, 의존성 변수2);
})
```

- **클래스 컴포넌트의 생명주기 함수과 가튼 기능을 하나로 통합한 기능을 제공**

## 4월 3일 강의

### 컴포넌트 만들기

1. 컴포넌트의 종류

- 리액트 초기버전을 사용할 때는 클래스형 컴포넌트를 주로 사용했습니다.
- 이후 Hook이라는 개념이 나오면서 최근에는 함수형 컴포넌트를 주요 사용합니다
- 예전에 작성된 코드나 문서들이 클래스형 컴포넌트를 사용하고 있기때문에
- 클래스형 컴포넌트와 컴포넌트의 생명주기에 관해서도 공부해 두어야합니다.

2. 함수형 컴포넌트

- Welcome 컴포넌트는 props를 받는다

3. 컴포넌트 이름 짓기

- 이름은 항상 대문자로 시작합니다.
- 왜냐하면 리액트는 소문자로 시작하는 컴포넌트를 DOM 태그로 인식하기 떄문입니다.
- 컴포넌트 파일 이름과 컴포넌트 이름은 같게 합니다.

4. 컴포넌트의 렌더링

- 렌더링의 과정은 다음 코드와 같습니다.

```jsx
function Welcome(props) {
	return <h1>안녕,{props.name}</h1>;
}
const element = <Welcome name="인재" />;
ReactDOM.render(element, document.getElementById("root"));
```

### 5.4 컴포넌트 형성

- 컴포넌트 합성은 여러개의 컴포넌트를 합쳐서 하나의 컴포넌트를 만드는것 입니다.
- 리액트에서는 컴포넌트 안에 또다른 컴포넌트를 사용할 수 있기 대문에, 복잡한 화면을 여러개의 컴포넌트로 나누어 구현 할 수 있습니다.

### 5.5 컴포넌트 추출

- 복잡한 컴포넌트를 쪼개서 여러개의 컴포넌트를 나눌 수도 있습니다.
- 큰 컴포넌트에서 일부를 추출해서 새로운 컴포넌트를 만드는 것입니다.
- 실무에서는 처음부터 1개의 컴포넌트에 하나의 기능만 사용하도록 설계하는것이 좋다.

### state

1. state?

- 리액트 컴포넌트의 상태
- 상태는 컴포넌트의 데이터를 의미. 즉 변경가능한 데이터를 의미
- state가 변하면 다시 렌더링 되기 때문에 렌더링과 관련된 값만 state에 포함시켜야 함

2. state의 특징

- 리액트만의 특별한 형태가 아니고 단지 자바스크립트 객체임
- state는 변경은 가능하지만 직접 수정이 안됨
- state를 변경하고자 할 때는 set함수를 사용

### 6.2 생명주기에 대해 알아보기

- 생명주기는 컴포넌트의 생성시점, 사용시점, 종료시점을 나타내는것입니다
- constructor가 실행되면서 컴포넌트가 생성됩니다.
- 생성직후 componentDidMount() 함수가 호출됩니다.
- 컴포넌트가 소멸하기 전까지 여러번 랜더링합니다.
- 렌더링은 props, setState(), forceUpdate()에 의해 상태가 변경되면 이루어집니다.
- 그리고 렌더링이 끝나면 componentDinUpdate()합수가 호출됩니다.
- 마지막으로 컴포넌트가 언마운트되면 componentWillUnmount() 함수가 호출됩니다.

## 3월 27일 강의

### 3.2의 역할

1. JSX는 내부적으로 XML/HTML 코드를 자바스크립트로 변환합니다
2. React가 createElement 함수를 사용하여 자동으로 자바스크립트로 변환해줍니다.
3. 만일 JS로 작업할 경우 직접 createElement함수를 사용해야합니다
4. 앞으로 설명하는 코드를 보면 알 수 있지만 결국JSX는 가독성을 높여주는 역할을 합니다.

### 3.3 JSX의 장점

1. 코드가 간결해집니다
2. 가독성이 향상 됩니다.
3. 인젝션 어택이라 불리는 해킹 방법을 방어함으로써 보안에 강합니다.

### 3.4 JSX 사용법

1. 모든 JS 문법 지원
2. JS 문법에 XML과 HTML을 섞어서 사용
3. 아래 코드의 2번 라인처럼 섞어서 사용하는 것
4. HTML이나 XML에 JS 코드를 사용하고 싶으면 {}괄호 사용

### 4장

### 4.1 엘리 머트에 대해 알아보기

1. 엘리멘트의 정의

- 엘리먼트는 리액트 앱을 구성하는 요소를 의미
- 공식 페이지에는 "엘리먼트는 리액트앱의 가장 작은 빌딩 블록들"
- 웹사이트의 경우 DOM 엘리먼트이며, HTML 요소를 의미

2. 리액트와 DOM 엘리멘트의 차이

- 리액트 엘리먼트는 Virtual DOM의 형태를 취하고 있음
- DOM 엘리먼트는 페이지의 모든 정보를 갖고있어 무겁다
- 리액트 엘리먼트는 변화한 부분만 갖고있어 가볍습니다.
- 업데이트 속도 DOM < Virtual DOM
- 메모리 DOM < Virtual DOM

3. 엘리먼트의 생김새

- 리액트 엘리먼트는 JS 객체의 형태로 존재
- 컴포넌트 (Button 등), 속성(Color 등) 및 내부의 모든 children을 포함하는 일반 JS객체입니다.
- 이 객체는 마음대로 변경할 수 없는 불변성을 갖고 있습니다.

### 4.2 엘리먼트 렌더링 하기

1. Root DOM node

- 다음 html 코드에는 id 값이 root인 div 태그로 단순하지만 리액트에 필수로 들어가는 아주 중요한 코드입니다.
- 이 div 태그안에 리액트 엘리먼트가 렌더링 되며, 이것을 Root DOM node라고 합니다.
  `<div id="root"><div>`

### 5장 컴포넌트와 props

### 5.1 컴포넌트에 대해 알아보기

- 리액트는 컴포넌트 기반 기반의 구조와 같습니다.
- 컴포넌트 구조라는 것은 작은 컴포넌트가 모여 큰 컴포넌트를 구성하고, 다시 이런 컴포넌트들이 모여서 전체 페이지를 구성한다는 것을 의미합니다.
- 컴포넌트 재사용이 가능하기 때문에 전체 코드의 양을 줄일 수 있어 개발 시간과 유지 보수 비용도 줄일수 있습니다.
- 컴포넌트는 자바 스크립트 함수처럼 입력과 출력이 있다는 면에서는 유사합니다.
- but 입력과 출력은 props가 담당하고, 출력은 리액트 엘리먼트의 형태로 출력됩니다.
- 엘리먼트를 필요한 만큼 만들어 사용한다는 면에서는 객체 지향의 개념과 비슷합니다.

### 5.2 props에 대해 알아보기

1. props의 개념

- Props : properties 의 약자
- props는 컴포넌트의 속성
- 컴포넌트에 어떤 속성, props를 넣느냐에 따라서 속성이 다른 엘리먼트가 출력됩니다.
- props는 컴포넌트에 전달 할 다양한 정보를 담고 있는 JS객체 입니다.

2. props의 특징

- 읽기 전용 즉 변경 할 수 없다
- 속성이 다른 엘리먼트를 생성 할려면 새로운 props를 컴포넌트에 전달하면 됩니다.

2. -1 pure 함수 vs impure 함수

- pure함수는 인수로 받은 정보가 함수 내부에서도 **변하지않는**함수
- impure 함수는 인수로 받은 정보가 함수 내부에서 **변화는**함수

3. props 사용법

- Profile 컴포넌트로 name, introduction, viewCount Props를 전달한다.
- 이때 전달되는 props는 다음과 같은 자바 스크립트 객체입니다.
- jsx를 사용하지 않는경우 props에 createElement함수 이용

## 3월 20일 강의

1. 다양한 JS UI 프레임 워크 : Stack Overflow trends
2. 사이트를 쉽고 빠르게 만들고, 관리하기 위해 만들어진 것이 바로 리액트

### 1-2 리액트의 장점

1. 빠른 업데이트와 렌더링 속도
2. 이것을 가능하게하는것이 바로 virtual DOM
3. DOM(Document Object Model) = XML,HTML 문서의 각 항목을 계층으로 표현하여 생성, 변형, 삭제할 수 있도록 돕는 인터페이스입니다.이것은 W3c의 표준입니다.
4. Virtual DOM은 DOM 조작이 비효을적인 이유로 속도가 느리기 때문에 고안된 방법입니다.
5. DOM은 동기식 . Virtual DOM은 비동기식 방법으로 렌더링을 합니다.

#### 2.컴포넌트 기반 구조

1. 리액트의 모든 페이지는 컴포넌트로 구성됩니다.
2. 하나의 컴포넌트는 다른 여러 개의 컴포넌트의 조합으로 구성할 수 있습니다
3. 그래서 리액트로 개발을 하다 보면 레고 블록을 조립나는 것쳐림 컴포넌트를 조합해서 웹사이트를 개발하게 됩니다. 그리고 재사용성이 뛰어난다.

#### 3. 재사용성

1. 반복적인 작업을 줄여주기 떄문에 생산성을 높여줍니다.
2. 또한 유지보수가 용이합니다
3. 재사용이 가능하려면 해달 모듈의 의존성이 없어야합니다.

#### 4. 든든한 지원군

메타에서 오픈소스 프로젝트로 관리하고 있음

#### 5. 활발한 지식공유와 커뮤니티

#### 6. 모바일 앱 개발가능

리액트 네이티브라는 모바일 환경 UI 프레임워크를 사용하면 크로스 플랫폼 모바일 앱을 개발할 수 있습니다.

### 1-3 리액트의 단점

#### 1. 방대한 학습량

자바스크립트를 공부한 경우 빠르게 학습 할 수 있습니다.

#### 2. 높은 상태 관리 복잡도

state, component life cycle등의 개념이 있지만 매우 어렵지 않음

### Package.json과 package-lock.json 차이

1. package.json은 패키지 의존성 관리 파일
2. 협업을 할때는 각자의 컴퓨터에 같은 패키지들을 설치해서 동일한 개발환경을 구현 해야하는데 이떄 사용하는것이 package.json이다
3. package.json의 경우는 version range를 사용한다.

## 3월 13일 강의

git config user.name = 깃이름 표시
git config user.email = 깃 이메일 표시

깃허브 커밋 테스트 이태석
노드 설치
노드 버전확인 : node -v
